infixOps ::= [
  "+":"true",
  "-":"true",
  "*":"true",
  "/":"true",
  default:"false"
]

// ----------------------  Expressions ----------------------
expr(ex) ::= <%
<if (ex.isLet)><ex:let()>
<elseif (ex.isPrim)><ex:prim()>
<elseif (ex.isDo)><ex:do()>
<elseif (ex.isOp)><ex:op()>
<elseif (ex.isIf)><ex:if()>
<else><ex:unsupported()>
<endif>
%>


unsupported(ex) ::= "UNSUPPORTED feature used!!!! (<ex>)"
let(ex) ::= <%<ex.bindings:binding();separator="\n">%>
prim(ex) ::= "<ex.val>"
do(ex) ::= <%<ex.exprs:expr();separator="\n">%>
if(ex) ::= <%
if (<ex.test:expr()>):
  <ex.conseq:expr()>
<if (ex.alt)>
else:
  <ex.alt:expr()>
<endif>
%>   

op(ex) ::= <%
<if (infixOps.(ex.op))>
  <expr(first(ex.rands))> <ex.op> <expr(first(rest(ex.rands)))>
<else>
  <ex.op>(<ex.rands:expr();separator=", ">)
<endif>
%>

binding(binding) ::= <%(<binding.vars:expr();separator=", ">) = <binding.expr:expr()>%>

// ----------------------  Common Table Elements ----------------------

tableSize(tdef) ::= <<
def size(self):
  return len(self.<first(tdef.fields)>)

>>

tableData(tdef) ::= <<
def data(self):
  return p.make_source(idx=range(len(self.<first(tdef.fields)>)), <tdef.fields:{f|<f>=self.<f>};separator=", ">)

>>

tableFields(fields) ::= <%_fields = [<fields:{f|'<f>'};separator=", ">]%>

// ----------------------  External Tables ----------------------

externalTable(tdef) ::= <<
class <tdef.name>:
  <tableFields(tdef.fields)>
  <tdef.fields:{f|<f> = None};separator="\n">

  def __init__(self, **kwargs):
    if (len(kwargs) == len(self._fields)):
      <tdef.fields:{f|self.<f>=kwargs['<f>']};separator="\n">
    else:
      raise Exception("Data not properly supplied to table <tdef.name>")

  <tableSize(tdef)>
  <tableData(tdef)>
>>


// ---------------------- Dependent Table ----------------------

dependUpdate(tableFields, ddef) ::= <<
for i in range(0, self._<ddef.source>.size()):
  <ddef.fields:{f|<f> = self._<ddef.source>.<f>[i]};separator="\n">
  <ddef.expr:expr()>
  <tableFields:{f|self.<f>.push(<f>)};separator="\n">
>>

dependentTable(tdef) ::= <<
class <tdef.name>:
  <tableFields(tdef.fields)>
  <tdef.depends:{d|_<d.source> = None};separator="\n">
  <tdef.fields:{f|<f> = None};separator="\n">

  def __init__(self, <tdef.depends:{d|<d.source>};separator=", ">):
    <tdef.depends:{d|self._<d.source> = <d.source>};separator="\n">

  def update(self):
    <tdef.fields:{f|self.<f> = []};separator="\n">
    <tdef.depends:{d|<dependUpdate(tdef.fields, d)>};separator="\n#----------\n">

  <tableSize(tdef)>
  <tableData(tdef)>
>>


// ---------------------- Root Class ----------------------

tableSetter(tdef) ::= <<
<if (!tdef.depends)>
def set_<tdef.name>(self, <tdef.fields:{f|<f>};separator=", ">):
  self.<tdef.name> = <tdef.name>(<tdef.fields:{f|<f>=<f>};separator=", ">)
<endif>
>>

renderer(def) ::= <%
  p.plot('<def.x>', '<def.y>', color='<def.color>', data_source=self.<def.source>.data(), <if (def.scatter)>scatter=True<endif>)

%>

classDef(className,tables,view) ::= <<

<tables:{t|<if (t.depends)><dependentTable(t)><else><externalTable(t)><endif>};separator="\n\n">

class <className>:
  <tables:{t|<t.name> = None};separator="\n">

  <tables:tableSetter()>

  def render(self):
    <tables:{t|<if (t.depends)><t.name>.update()<endif>};separator="\n">
    <view.renders:renderer();separator="\n">
>>

// ---------------------- Furniture ----------------------

program(def) ::= <<
<header(def.header.debug)>

<classDef(def.header.name, def.tables, def.view)>

<footer(def.header.name, def.header.debug)> 
>>

header(testharness) ::= <<
#Debug set to '<testharness>'
from webplot import p 
<if(testharness)>
import numpy as np 
<endif>
>>



footer(name, testharness) ::= <<
<if (testharness)>
x = np.arange(100) / 6.0 
y = np.sin(x) 
z = np.cos(x) 
plot = <name>()
plot.set_dataset(x,y,z)
plot.render()
<endif>
>>
