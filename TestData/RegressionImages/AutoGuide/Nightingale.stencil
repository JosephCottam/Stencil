STREAM: File
NAME: Deaths
TUPLE_SIZE: 3
SEPARATOR: \s*,\s*
SOURCE: ./NightingaleCrimeaSplit.csv
SKIP: 1
STRICT: true

stream Deaths(date, type, count)

layer Rose["SLICE"]
guide
  legend[X: -75, Y:50] from FILL_COLOR

  pointLabels from ID
    TEXT: MakeLabel(ID)         /*@\label{rose:postProcessStart}@*/
    (X,Y): MinRadius.query(50, X, Y, OUTER.0, OUTER.1)
    REGISTRATION: "CENTER"
    FONT: @Font{4}          /*@\label{rose:postProcessEnd}@*/

from Deaths
   local(month, year) : ParseDate(date)
   ID: Concatenate(type, ":", local.month)
   FILL_COLOR: ColorBy(type)
   PEN: @Stroke{.5}
   PEN_COLOR: @Color{Gray70}
   SIZE:* Scale[min:0, max:250](count)
   Z: Mult(-1, count)
   (X,Y): (0,0)
   (START, END): Sub1(local.month) -> Partition(_)  
    
operator ColorBy (t) -> (C)
   (t=~"wounds") => C:@Color{LightPink}
   (t=~"other") => C:@Color{DarkGray}
   (t=~"disease") => C:@Color{LightBlue}

operator ParseDate (d) -> (m,y)
   default => (m,y): [s] IndexOf(d, "/") -> 
                     [m] Substring(d, 0, s) ->
                     Add1(s) -> Substring(d, _, -1) -> (m, _) 

operator MakeLabel(id) -> (text)
   (id =~ ".*dise.*") => text: IndexOf(id,":") -> Add1(_) -> Substring(id, _, -1) -> MonthAbr(_)
   default => text: ""

operator Partition(n) -> (start, end)
   default => (start, end): Sub(12, n) -> [n] Sub(_,4) -> 
                          [end] Mult(30, n) ->
                          Add1(n) -> Mult(30,_) -> (_,end)


operator MonthAbr (n) -> (month) 
   (n=1) => month: "Jan"
   (n=2) => month: "Feb"
   (n=3) => month: "Mar"
   (n=4) => month: "Apr"
   (n=5) => month: "May"
   (n=6) => month: "Jun"
   (n=7) => month: "Jul"
   (n=8) => month: "Aug"
   (n=9) => month: "Sep"
   (n=10) => month: "Oct"
   (n=11) => month: "Nov"
   (n=12) => month: "Dec"
   default => month: "ERROR"


java MinRadius {	/*@\label{rose:javaStart}@*/
   public MinRadius(OperatorData od) {super(od);}

   @Facet(memUse="FUNCTION", prototype="(double X, double Y)")
   public double[] query(double Min, double X1, double Y1, double X, double Y) {
       double rise = Y-Y1;
       double run = X-X1;
       double radius = Math.sqrt(Math.pow(rise,2) + Math.pow(run,2));
       double ratio = radius >0 ? Min/radius : 1;
       if (ratio > 1) {
          Y = Y1 + (ratio * rise);
          X = X1 + (ratio * run);
       }
       return new double[]{X,Y};
   }
}

