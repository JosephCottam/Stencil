STREAM: File
NAME: VertexList
HEADER: ID1, ID2
SEPARATOR: ,
SOURCE: ./er_100_0.005.adj
SKIP: 1
STRICT: true
STREAM: File
NAME: BFS
HEADER: ID
SEPARATOR: \s+
SOURCE: ./er_100_0.005.bfs
SKIP: 1
STRICT: true

stream BFS (ID) 
stream VertexList (ID1, ID2)

order BFS > VertexList			/*Load the node list before the vertex list.*/

layer Nodes
from BFS 
	ID: ID
	REGISTRATION : "CENTER"
	FILL_COLOR:  @Color{BLUE}
	(SHAPE, SIZE) : ("ELLIPSE", 10)
	(X,Y) : Ordering(ID) -> Triangular(VALUE) -> (X,Y)
	 

layer Labels["TEXT"]				/*Changes the glyph type. All layers have only one glyph type.*/
from BFS
	ID : ID
	(X,Y): Nodes.find(ID) -> (X,Y)
	TEXT: ID
	FONT: @Font{10}
	COLOR: @Color{GRAY60}

layer Edges["LINE"]
from VertexList 
	ID: Concatenate(ID1,ID2)
	(X.1, Y.1): Nodes.find(ID1) -> (X,Y)
	(X.2, Y.2): Nodes.find(ID2) ->  (X,Y)
	PEN_COLOR: @Color{GRAY30,80}


operator Ordering (ID)->(VALUE)  
	(ALL) => VALUE : Index(ID)

java Triangular {
    public Triangular(OperatorData od) {super(od);}
    
    @Facet(memUse="FUNCTION", prototype="(X,Y)", alias={"map","query"})
    public double[] query(int seq) {
        seq = seq+1;
        int base = (int) Math.ceil(Math.sqrt(seq));
        int X = (seq/base) * 10 *base;
        int Y = (seq%base) * 10 *base;
        return new double[]{X,Y};
    }    
}
