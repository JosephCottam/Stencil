STREAM: File
NAME: Edges
TUPLE_SIZE: 2
SEPARATOR: ,
SOURCE: ./er_100_0.005.adj
CHECKHEADER: true

stream Edges (ID1, ID2)


/*Layout values in a circle.  Circle radius grows as value count increases.*/

layer Nodes
from Edges
	ID: ID1 
	FILL_COLOR: @Color{MAROON}
	(X,Y):* Ordering(ID1) -> Circular.query(Ordering.index) -> (Circular.X, Circular.Y)
	(REGISTRATION, SHAPE, SIZE) : ("CENTER", "ELLIPSE", 2)
from Edges
	ID: ID2
	FILL_COLOR: @Color{MAROON}
	(X,Y):* Ordering(ID2) -> Circular.query(Ordering.index) -> (Circular.X,Circular.Y)
	(REGISTRATION, SHAPE, SIZE) : ("CENTER", "ELLIPSE", 2)

layer Edges["LINE"]
default
	PEN_COLOR: @Color{GRAY80, .8}
from Edges 
	ID: Concatenate(ID1,ID2)
	(X1, Y1):* Nodes.find(ID1) -> (Nodes.X,Nodes.Y)
	(X2, Y2):* Nodes.find(ID2) ->  (Nodes.X,Nodes.Y)
	PEN: @Stroke{.25}

operator Ordering (ID)->(index)  
	default => index : Index(ID)

java Circular {
    int max=0;
    
    @Facet(memUse="WRITER", prototype="(double X, double Y)")
    public double[] map(int seq) {
        if (seq+1 > max){ max=seq+1;}
        return query(seq);
    }
    
    @Facet(memUse="READER", prototype="(sdouble X, double Y)")
    public double[] query(int seq) {
        seq = seq+1;
        double radius = Math.sqrt(max)+ max/100 * 20;
        double offset = Math.toRadians(seq/max*360);
    
        double X = radius * Math.cos(offset);
        double Y = radius * Math.sin(offset);
        return new double[]{X,Y}; 
    }
}