STREAM: File
NAME: MTTSource
HEADER:  graphLabel | axis1A | axis1B | axis2A |  axis2B | suite_name | pass  | fail
SEPARATOR: \s*\|\s*
SOURCE: ./18049-arch-compiler.output.txt
SKIP: 2
STRICT: false
STREAM: File
NAME: MTTNotApplicable
HEADER: axis1A, axis1B, axis2A, axis2B
SEPARATOR: ,\s*
SOURCE: ./NoData-Comp.txt
SKIP: 1
STRICT: true

stream MTTSource(graphLabel, axis1A, axis1B, axis2A, axis2B, suite_name, pass, fail)
stream MTTNotApplicable(axis1A, axis1B, axis2A, axis2B)

order MTTSource > MTTNotApplicable

layer Trivial
from MTTSource
	filter (suite_name =~ "trivial")
	ID : Concatenate(axis1A, axis1B, axis2A, axis2B) ->  VALUE
	(X,Y): Layout(axis1A, axis1B, axis2A, axis2B) ->(X,Y)
 	FILL_COLOR : BasicFails(fail) -> (C)
	SIZE: 50
	SHAPE: "RECTANGLE"
	REGISTRATION: "TOP_LEFT"

layer Others[PIE]
from MTTSource
	filter(suite_name !~"trivial")
	ID : Concatenate(axis1A, axis1B, axis2A, axis2B, suite_name) -> VALUE
	(X,Y): Layout.suite(axis1A, axis1B, axis2A, axis2B, suite_name) -> (X,Y)
	SIZE: 13
	PEN: @Stroke{3}
	PEN_COLOR: RelativeFails(fail, pass)
	SLICE: fail
	FIELD: pass
	SLICE_COLOR: Palet("FAIL")
	FIELD_COLOR: @Color{WHITE}

layer NotApplicable
from MTTNotApplicable
	ID: Concatenate(axis1A, axis1B, axis2A, axis2B) 
	(X,Y) : Layout.query(axis1A, axis1B, axis2A, axis2B) -> (X,Y)
	FILL_COLOR: Palet("N/A") -> (C)
	SIZE: 50
	SHAPE: "RECTANGLE"
	REGISTRATION: "TOP_LEFT"
	PATTERN: "HATCH"
	PATTERN_WEIGHT: 1.1

layer SubLabels[TEXT]
from MTTSource
	filter(suite_name !~"trivial")
	local(ID): Concatenate(axis1A, axis1B, axis2A, axis2B, suite_name)
	ID: local[ID]
	(X,Y): Others.find(local[ID]) -> (X,Y)
	TEXT: suite_name
	FONT: @Font{5}
	ROTATION: -45
	REGISTRATION: "CENTER"
	FONT_STYLE: "BOLD"
	COLOR: @Color{0,0,0,166}

layer Labels[TEXT]
from MTTSource
	ID: Concatenate(axis1A, axis1B) -> VALUE
	X: Layout(axis1A, axis1B, axis2A, axis2B) -> Add(X, 12) -> VALUE
	TEXT: Concatenate(axis1A, "\n", axis1B) -> VALUE
	(Y, WIDTH): (-5, 50)
	(ROTATION, JUSTIFY): ("VERTICAL", "LEFT")
from MTTSource
	ID: Concatenate(axis2A, axis2B) -> VALUE
	Y: Layout(axis1A, axis1B, axis2A, axis2B) -> Add(Y, 12) -> VALUE
	TEXT: Concatenate(axis2A, "\n", axis2B) -> Break(VALUE) -> Label
	X : -5
	(JUSTIFY, REGISTRATION): ("RIGHT", "TOP_RIGHT")
from MTTSource
	ID: graphLabel
	Y: NamesIndex(graphLabel) -> VALUE
	TEXT: graphLabel
	X: -375


layer Legend[IMAGE]
from MTTSource
	ID: "LegendImage"
	FILE: "./SeeTest-Key.png"
	(X,Y,WIDTH,HEIGHT) : (-375,10,200, 200)


layer GridLines[LINE]
from MTTSource
	ID : Concatenate(axis1A, axis1B) -> VALUE
	(X.1, X.2): Layout(axis1A, axis1B, axis2A, axis2B) -> (X, X)
	Y.1 :-5
	Y.2 :* EqualHeight(axis1A, axis1B, axis2A, axis2B) -> Y2
	PEN_COLOR : Palet("GRID")
from MTTSource
	ID : Concatenate(axis2A, axis2B) -> VALUE
	(Y.1,Y.2) : Layout(axis1A, axis1B, axis2A, axis2B) -> (Y,Y)
	X.1 : -5
	X.2 :* EqualWidth(axis1A, axis1B, axis2A, axis2B) -> (X2)
	PEN_COLOR: Palet("GRID") -> (C)

operator EqualWidth (axis1A, axis1B, axis2A, axis2B) -> (X2)
	ALL => X2 : Layout(axis1A, axis1B, axis2A, axis2B) -> Add(X, 55) -> Max[range: ALL](VALUE)

operator EqualHeight (axis1A, axis1B, axis2A, axis2B) -> (Y2)
	ALL => Y2 : Layout(axis1A, axis1B, axis2A, axis2B) -> Add(Y, 55) -> Max[range: ALL](VALUE)


operator NamesIndex(ID) -> (VALUE)
	ALL => VALUE: Index(ID) -> (VALUE)

operator BasicFails(fails) -> (C)
	(fails = 0) => C: Palet("PASS") -> SetAlpha(51, C)
	(fails > 0) => C: Palet("FAIL") -> SetAlpha(102,C)

operator RelativeFails(fails, passes) -> (C)
	(passes= 0) => C: @Color{BLACK}
	(fails = 0) => C: Palet("PASS")
	(fails > 0) => C: Palet("FAIL")

operator Palet(Name) -> (C)
	(Name =~"FAIL")    => C: @Color{200,30,30}
	(Name =~"PASS")    => C: @Color{0,180,0}
	(Name =~"MISSING") => C: @Color{WHITE}
	(Name =~"N/A")     => C: @Color{GRAY90}
	(Name =~"GRID")    => C: @Color{GRAY80}

python Break
facet map (Orig) -> (Label)
{
	Label=Orig.replace("Absoft: Absoft ", "")
	Label=Label.replace("Absoft: ", "")
	Label=Label.replace(",", "\n")
}



python Layout
facet init {
	XIndex= []
	YIndex = []
	majorOffset = 50
	suites = ["ibm", "imb", "intel", "mpicxx"]
	border = 10
	minorOffset = 18

	def queryLayout(X1,X2,Y1,Y2):
		XBase = X1+X2
		YBase = Y1+Y2
		if (XBase not in XIndex): return (-375,300)
		if (YBase not in YIndex): return (-375,300)
		X = XIndex.index(XBase) * majorOffset
		Y = YIndex.index(YBase) * majorOffset
		return (X,Y)
	
	def baseLayout(X1, X2,Y1,Y2):
		XBase = X1+X2
		YBase = Y1+Y2
		if (XBase not in XIndex): XIndex.append(XBase)
		if (YBase not in YIndex): YIndex.append(YBase)
		X = XIndex.index(XBase) * majorOffset
		Y = YIndex.index(YBase) * majorOffset
		return (X,Y)
		
	def suiteLayout(baseX, baseY, suite):
		if (suite not in suites): suites.append(suite)
		offset = suites.index(suite)
		X = baseX + border + (offset%2 * minorOffset)
		Y = baseY + border+ (offset/2 * minorOffset)
		return (X,Y)
	
	def suiteLayout(baseX, baseY, suite):
		if (suite not in suites): suites.append(suite)
		offset = suites.index(suite)
		X = baseX + border + (offset%2 * minorOffset)
		Y = baseY + border+ (offset/2 * minorOffset)
		return (X,Y)	
}

facet suite(X1,X2,Y1,Y2, suite) -> (X,Y)
{
	(X,Y) = baseLayout(X1,X2,Y1,Y2)
	(X,Y) = suiteLayout(X,Y, suite)
}
facet map   (X1,X2,Y1,Y2) -> (X,Y) {(X,Y) = baseLayout(X1,X2,Y1,Y2)}
facet query (X1,X2,Y1,Y2) -> (X,Y) {(X,Y) = queryLayout(X1,X2,Y1,Y2)}

