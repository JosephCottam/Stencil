import PatternUtils
import JavaC

stream MTTSource(graphLabel, axis1A, axis1B, axis2A, axis2B, suite_name, pass, fail)
   from Text["./18049-arch-compiler.output.txt", sep:"\\s*\\|\\s*", skip:2, strict: false]
stream MTTNotApplicable(axis1A, axis1B, axis2A, axis2B)
   from Text["./NoData-Comp.txt"]

order MTTSource > MTTNotApplicable

layer Trivial
from MTTSource
    filter (suite_name =~ "trivial")
    ID : Concatenate(axis1A, axis1B, axis2A, axis2B)
    (X,Y): Layout(axis1A, axis1B, axis2A, axis2B)
    FILL_COLOR : BasicFails(fail)
    SIZE: 50
    SHAPE: "RECTANGLE"
    REGISTRATION: "TOP_LEFT"


layer NotApplicable
from MTTNotApplicable
    ID: Concatenate(axis1A, axis1B, axis2A, axis2B) 
    (X,Y) : Layout.query(axis1A, axis1B, axis2A, axis2B)
    SIZE: 50
    SHAPE: "RECTANGLE"
    REGISTRATION: "TOP_LEFT"
     FILL_COLOR: [fore] Palette("N/A") -> PatternFill("hatch", fore, NULL, 10, 1.1)


layer Others["PIE"]
from MTTSource
    filter(suite_name !~"trivial")
    ID : Concatenate(axis1A, axis1B, axis2A, axis2B, suite_name)
    (X,Y): Layout.suite(axis1A, axis1B, axis2A, axis2B, suite_name)
    SIZE: 13
    PEN: Stroke{3}
    PEN_COLOR: RelativeFails(fail, pass)
    SLICE: fail
    FIELD: pass
    SLICE_COLOR: Palette("FAIL")
    FIELD_COLOR: Color{WHITE}


layer SubLabels["TEXT"]
from MTTSource
    filter(suite_name !~"trivial")
    local(ID): Concatenate(axis1A, axis1B, axis2A, axis2B, suite_name)
    ID: local.ID
    (X,Y): Others.find(local.ID) -> (Others.X, Others.Y)
    TEXT: suite_name
    FONT: Font{5}
    ROTATION: -45
    REGISTRATION: "CENTER"
    FONT_STYLE: "BOLD"
    COLOR: Color{0,0,0,166}

layer YLabels["TEXT"]
from MTTSource
    ID: Concatenate(axis1A, axis1B)
    X: Layout(axis1A, axis1B, axis2A, axis2B) -> Add(Layout.X, 12)
    TEXT: Concatenate(axis1A, "\n", axis1B)
    (Y, WIDTH): (5, 50)
    (ROTATION, JUSTIFY): ("VERTICAL", "LEFT")



layer XLabels["TEXT"]
from MTTSource
    ID: Concatenate(axis2A, axis2B)
    Y: Layout(axis1A, axis1B, axis2A, axis2B) -> Sub(Layout.Y, 12)
    TEXT: Concatenate(axis2A, "\n", axis2B) -> Break(_) -> Break.Label
    X : -5
    (JUSTIFY, REGISTRATION): ("RIGHT", "TOP_RIGHT")



layer CanvasLabel["TEXT"]
from MTTSource
    ID: graphLabel
    Y: NamesIndex(graphLabel)
    TEXT: graphLabel
    X: -375

layer Legend["IMAGE"]
from MTTSource
    ID: "LegendImage"
    FILE: "./SeeTest-Key.png"
    (X,Y,WIDTH,HEIGHT) : (-375,-10,200, 200)


layer XGridLines["LINE"]
from MTTSource
    ID : Concatenate(axis1A, axis1B)
    (X1, X2): Layout(axis1A, axis1B, axis2A, axis2B) -> (Layout.X, Layout.X)
    Y1 : 5
    Y2 :* EqualHeight(axis1A, axis1B, axis2A, axis2B) 
    PEN_COLOR : Palette("GRID")

layer YGridLines["LINE"]
from MTTSource
    ID : Concatenate(axis2A, axis2B)
    (Y1,Y2) : Layout(axis1A, axis1B, axis2A, axis2B) -> (Layout.Y, Layout.Y)
    X1 : -5
    X2 :* EqualWidth(axis1A, axis1B, axis2A, axis2B)
    PEN_COLOR: Palette("GRID")

operator EqualWidth (axis1A, axis1B, axis2A, axis2B) -> (X2)
    default => X2 : Layout(axis1A, axis1B, axis2A, axis2B) -> Add(Layout.X, 55) -> Range[ALL](@Max, Add)

operator EqualHeight (axis1A, axis1B, axis2A, axis2B) -> (Y2)
    default => Y2 : Layout(axis1A, axis1B, axis2A, axis2B) -> Sub(Layout.Y, 55) -> Range[ALL](@Min, Sub)


operator NamesIndex(ID) -> (VALUE)
    default => VALUE: Index(ID)

operator BasicFails(fails) -> (C)
    (fails = 0) => C: Palette("PASS") -> SetAlpha(51, Palette.C)
    (fails > 0) => C: Palette("FAIL") -> SetAlpha(102, Palette.C)

operator RelativeFails(fails, passes) -> (C)
    (passes= 0) => C: Color{BLACK}
    (fails = 0) => C: Palette("PASS")
    (fails > 0) => C: Palette("FAIL")

operator Palette(Name) -> (C)
    (Name =~"FAIL")    => C: Color{200,30,30}
    (Name =~"PASS")    => C: Color{0,180,0}
    (Name =~"MISSING") => C: Color{WHITE}
    (Name =~"N/A")     => C: Color{GRAY90}
    (Name =~"GRID")    => C: Color{GRAY80}


operator Break : JavaC
   [@"
   \@Facet(memUse="FUNCTION", prototype="(Label)", alias={"map","query"})
   public String query(String original) {
      return original
               .replace("Absoft: Absoft ", "")
               .replace("Absoft: ", "")
               .replace(",", "\n");
   }"@]


operator Layout : JavaC
    [header: "import java.util.*;",
     body: @"
   static final List<String> suites = Arrays.asList("ibm", "imb", "intel", "mpicxx");
   static final double majorOffset = 50;
   static final int border = 15;
   static final int minorOffset = 18;
   static final List<String> XIndex = new ArrayList();
   static final List<String> YIndex = new ArrayList();
   
   \@Facet(memUse="OPAQUE", prototype="(double X, double Y)")
   public double[] suite(String X1, String X2, String Y1, String Y2, String suite) {
      double[] base = map(X1,X2,Y1,Y2);
      if (suites.indexOf(suite) <0) {throw new IllegalArgumentException("Unknown suite: " + suite);}
      int offset = suites.indexOf(suite);
      double x = base[0] + border + (offset%2 * minorOffset);
      double y = -(-base[1] + border + (offset/2 * minorOffset));
      return new double[]{x,y};
   }
   
   \@Facet(memUse="WRITER", prototype="(double X, double Y)", counterpart="query")
   public double[] map(String X1, String X2, String Y1, String Y2) {
        String XBase = X1+X2;
        String YBase = Y1+Y2;
        if (!XIndex.contains(XBase)) {XIndex.add(XBase);}
        if (!YIndex.contains(YBase)) {YIndex.add(YBase);}
        double X = XIndex.indexOf(XBase) * majorOffset;
        double Y = -(YIndex.indexOf(YBase) * majorOffset);
        return new double[]{X,Y};
   }

   \@Facet(memUse="READER", prototype="(double X, double Y)")
   public double[] query(String X1, String X2, String Y1, String Y2) {
        String XBase = X1+X2;
        String YBase = Y1+Y2;
        if (!XIndex.contains(XBase)) {return new double[]{-375,300};}
        if (!YIndex.contains(YBase)) {return new double[]{-375,300};}
        double X = XIndex.indexOf(XBase) * majorOffset;
        double Y = -(YIndex.indexOf(YBase) * majorOffset);
        return new double[]{X,Y};
   }"@]

