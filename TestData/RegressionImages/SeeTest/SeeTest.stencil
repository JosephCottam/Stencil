STREAM: File
NAME: MTTSource
HEADER:  graphLabel | axis1A | axis1B | axis2A |  axis2B | suite_name | pass  | fail
SEPARATOR: \s*\|\s*
SOURCE: ./18049-arch-compiler.output.txt
SKIP: 2
STRICT: false
STREAM: File
NAME: MTTNotApplicable
HEADER: axis1A, axis1B, axis2A, axis2B
SEPARATOR: ,\s*
SOURCE: ./NoData-Comp.txt
SKIP: 1
STRICT: true

stream MTTSource(graphLabel, axis1A, axis1B, axis2A, axis2B, suite_name, pass, fail)
stream MTTNotApplicable(axis1A, axis1B, axis2A, axis2B)

order MTTSource > MTTNotApplicable

layer Trivial
from MTTSource
	filter (suite_name =~ "trivial")
	ID : Concatenate(axis1A, axis1B, axis2A, axis2B)
	(X,Y): Layout(axis1A, axis1B, axis2A, axis2B) ->(X,Y)
 	FILL_COLOR : BasicFails(fail) -> (C)
	SIZE: 50
	SHAPE: "RECTANGLE"
	REGISTRATION: "TOP_LEFT"

layer Others["PIE"]
from MTTSource
	filter(suite_name !~"trivial")
	ID : Concatenate(axis1A, axis1B, axis2A, axis2B, suite_name)
	(X,Y): Layout.suite(axis1A, axis1B, axis2A, axis2B, suite_name) -> (X,Y)
	SIZE: 13
	PEN: @Stroke{3}
	PEN_COLOR: RelativeFails(fail, pass)
	SLICE: fail
	FIELD: pass
	SLICE_COLOR: Palet("FAIL")
	FIELD_COLOR: @Color{WHITE}

layer NotApplicable
from MTTNotApplicable
	ID: Concatenate(axis1A, axis1B, axis2A, axis2B) 
	(X,Y) : Layout.query(axis1A, axis1B, axis2A, axis2B) -> (X,Y)
	FILL_COLOR: Palet("N/A") -> (C)
	SIZE: 50
	SHAPE: "RECTANGLE"
	REGISTRATION: "TOP_LEFT"
	PATTERN: "HATCH"
	PATTERN_WEIGHT: 1.1

layer SubLabels["TEXT"]
from MTTSource
	filter(suite_name !~"trivial")
	local(ID): Concatenate(axis1A, axis1B, axis2A, axis2B, suite_name)
	ID: local[ID]
	(X,Y): Others.find(local[ID]) -> (X,Y)
	TEXT: suite_name
	FONT: @Font{5}
	ROTATION: -45
	REGISTRATION: "CENTER"
	FONT_STYLE: "BOLD"
	COLOR: @Color{0,0,0,166}

layer Labels["TEXT"]
from MTTSource
	ID: Concatenate(axis1A, axis1B)
	X: Layout(axis1A, axis1B, axis2A, axis2B) -> Add(X, 12)
	TEXT: Concatenate(axis1A, "\n", axis1B)
	(Y, WIDTH): (-5, 50)
	(ROTATION, JUSTIFY): ("VERTICAL", "LEFT")
from MTTSource
	ID: Concatenate(axis2A, axis2B)
	Y: Layout(axis1A, axis1B, axis2A, axis2B) -> Add(Y, 12)
	TEXT: Concatenate(axis2A, "\n", axis2B) -> Break(value) -> Label
	X : -5
	(JUSTIFY, REGISTRATION): ("RIGHT", "TOP_RIGHT")
from MTTSource
	ID: graphLabel
	Y: NamesIndex(graphLabel)
	TEXT: graphLabel
	X: -375


layer Legend["IMAGE"]
from MTTSource
	ID: "LegendImage"
	FILE: "./SeeTest-Key.png"
	(X,Y,WIDTH,HEIGHT) : (-375,10,200, 200)


layer GridLines["LINE"]
from MTTSource
	ID : Concatenate(axis1A, axis1B)
	(X.1, X.2): Layout(axis1A, axis1B, axis2A, axis2B) -> (X, X)
	Y.1 :-5
	Y.2 :* EqualHeight(axis1A, axis1B, axis2A, axis2B) -> Y2
	PEN_COLOR : Palet("GRID")
from MTTSource
	ID : Concatenate(axis2A, axis2B)
	(Y.1,Y.2) : Layout(axis1A, axis1B, axis2A, axis2B) -> (Y,Y)
	X.1 : -5
	X.2 :* EqualWidth(axis1A, axis1B, axis2A, axis2B) -> (X2)
	PEN_COLOR: Palet("GRID") -> (C)

operator EqualWidth (axis1A, axis1B, axis2A, axis2B) -> (X2)
	ALL => X2 : Layout(axis1A, axis1B, axis2A, axis2B) -> Add(X, 55) -> Max[range: ALL](sum)

operator EqualHeight (axis1A, axis1B, axis2A, axis2B) -> (Y2)
	ALL => Y2 : Layout(axis1A, axis1B, axis2A, axis2B) -> Add(Y, 55) -> Max[range: ALL](sum)


operator NamesIndex(ID) -> (VALUE)
	ALL => VALUE: Index(ID)

operator BasicFails(fails) -> (C)
	(fails = 0) => C: Palet("PASS") -> SetAlpha(51, C)
	(fails > 0) => C: Palet("FAIL") -> SetAlpha(102,C)

operator RelativeFails(fails, passes) -> (C)
	(passes= 0) => C: @Color{BLACK}
	(fails = 0) => C: Palet("PASS")
	(fails > 0) => C: Palet("FAIL")

operator Palet(Name) -> (C)
	(Name =~"FAIL")    => C: @Color{200,30,30}
	(Name =~"PASS")    => C: @Color{0,180,0}
	(Name =~"MISSING") => C: @Color{WHITE}
	(Name =~"N/A")     => C: @Color{GRAY90}
	(Name =~"GRID")    => C: @Color{GRAY80}

java Break
{
   @Facet(memUse="FUNCTION", prototype="(Label)", alias={"map","query"})
   public String query(String original) {
      return original
                .replace("Absoft: Absoft ", "")
                .replace("Absoft: ", "")
                .replace(",", "\n");
   }
}

java Layout 
{import java.util.*;}
{
   static final List<String> suites = Arrays.asList("ibm", "imb", "intel", "mpicxx");
   static final double majorOffset = 50;
   static final int border = 10;
   static final int minorOffset = 18;
   static final List<String> XIndex = new ArrayList();
   static final List<String> YIndex = new ArrayList();
   
   @Facet(memUse="WRITER", prototype="(double X, double Y)")
   public double[] suite(String X1, String X2, String Y1, String Y2, String suite) {
      double[] base = map(X1,X2,Y1,Y2);
      if (suites.indexOf(suite) <0) {throw new IllegalArgumentException("Unknown suite: " + suite);}
      int offset = suites.indexOf(suite);
      double x = base[0] + border + (offset%2 * minorOffset);
      double y = base[1] + border+ (offset/2 * minorOffset);
      return new double[]{x,y};
   }
   
   @Facet(memUse="WRITER", prototype="(double X, double Y)")
   public double[] map(String X1, String X2, String Y1, String Y2) {
        String XBase = X1+X2;
        String YBase = Y1+Y2;
        if (!XIndex.contains(XBase)) {XIndex.add(XBase);}
        if (!YIndex.contains(YBase)) {YIndex.add(YBase);}
        double X = XIndex.indexOf(XBase) * majorOffset;
        double Y = YIndex.indexOf(YBase) * majorOffset;
        return new double[]{X,Y};
   }

   @Facet(memUse="READER", prototype="(double X, double Y)")
   public double[] query(String X1, String X2, String Y1, String Y2) {
        String XBase = X1+X2;
        String YBase = Y1+Y2;
        if (!XIndex.contains(XBase)) {return new double[]{-375,300};}
        if (!YIndex.contains(YBase)) {return new double[]{-375,300};}
        double X = XIndex.indexOf(XBase) * majorOffset;
        double Y = YIndex.indexOf(YBase) * majorOffset;
        return new double[]{X,Y};
   }
}