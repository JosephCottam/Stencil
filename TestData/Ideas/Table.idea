Some data is staticÉand some algorithms are better viewed as tables anyway (layouts, Voronoi cells, set sampling).  
Provide a table type for Stencil that is like a layer, but is not rendered. 
The system "knows" about about tables and can use them intelligently (e.g., share columns with them, control operator instances).


table ZipCodes["Dict"]
from Zips
   (Zip, X,Y,City,State) : (Zip,X,Y,City, State)
   Order: Zip

layer scribble
from ZipCodes
  group: State
  Order: Zip
  (X,Y) : (X,Y)
  Color: Coloring(State)

//This would only store the information once, but use it for both the table and the layer.



-----------------------
// Osciliscope using table and a sampling strategy....
import Time

stream data(v) from Text["StdIn"]

table subset[sample:"newest", size:1000]
from data
  v : v
  time: CurrentMillis() -> [Min] Range[ALL](v, @Min) -> Sub(CurrentMillis,Min)

layer scope["polyline"]
from subset
  ID: Count()
  X:* Scale[0,100](time)
  Y: Scale[0,100](v)

//Big questions rest around handling WRITER facets.
//If they are only used in the context of table consumption, then invoking duplicate on STREAM_START makes sense;
//   work with the current collection AS IF it were the whole stream.
//However, if WRITER facets are invoked on operators whose READER facets are used outside of
//  table consumption, I don't know how to make the memory use clear...especially if other WRITER facets are
//  also invoked.
  
  
Table MAY permit the guide system to be expressed entirely in stencil:
The monitor operator is used with the sample operator to generate a stream.
The stream is stored in a table.
The table is used as the input to the guide layer.
On sample production, the old table contents are deleted (much as the layer values are deleted when a table iteration is initiated)
  
  
  
///Transformation
// Osciliscope using table and a sampling strategy....
stream data(v) from Text["StdIn"]
table subset[sample:"newest", n:1000]
from data
  v : v
  time: CurrentMillis() -> [Min] Range[ALL](v, @Min) -> Sub(CurrentMillis,Min)

layer scope["polyline"]
from subset
  ID: Count()
  X:* Scale[0,100](time)
  Y: Scale[0,100](v)



BECOMES


stream data(v) from Text["StdIn"]

table subset
from data
  filter(prefilter.#keep)
  prefilter(#keep) : sample1.keep(data.*)
  v : v
  time: CurrentMillis() -> [Min] Range[ALL](v, @Min) -> Sub(CurrentMillis,Min)
from data
  () : sample1.reduce() -> subset.remove(sample1.*)
  

stream subsetStream(v,time)
from #Signal
  (v, time) : scope.reset() -> Count1.reset() -> Scale2.reset() -> Scale3.reset()
              subset.tupleList() -> * 


operator sample1:sample(@newest1)	//Sample is the default table type.
operator newest1:newest[n:1000]     //Newest is the sample type


layer scope["polyline"]
from subset
  ID: Count1()
  X:* Scale2[0,100](time)
  Y: Scale3[0,100](v)

  
  
  
  
OR MAYBE 



stream data(v) from Text["StdIn"]

table subset
from data
  filter(prefilter.#keep)
  prefilter(#keep) : sample1.keep(data.*)
  v : v
  time: CurrentMillis() -> [Min] Range[ALL](v, @Min) -> Sub(CurrentMillis,Min)
from data
  () : sample1.reduce() -> subset.remove(sample1.*)
  


layer scope["scopeWrapper"]
from subset
  (table): subset.tuples() -> *


(group scope
  stream tableData(table)

  layer scopePlot["scopeBasis"]
   from tableData
     ID: Count()
     (v,time): MultiResult(*) -> *
     (): Sub1(ID) -> scopePlot.delete(_)
)

layer scope["polyline"]
from subset  
  ID: Count1()
  X:* Scale2[0,100](time)
  Y: Scale3[0,100](v)
