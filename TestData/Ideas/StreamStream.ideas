Custom filters need to be constructable so things like:
The A values of Foo sum to the current value of bar.
This requires a set of buffers to be passed in and a set of indexes to be passed out.
The indexes go pair-wise witht the buffers to indicate which elements of the buffers
passed the test.  What would the syntax be?  A specializer on filter?

stream Output(A,B,C,D,E,F)
   from Foo[1..n], Bar[-5..n]
   emit consuming[Bar]
        filter(Foo.A == Bar.D)
       (A,B,C,D,E,F): Foo.A, Foo.B, Foo.C, Bar.D, Bar.E, Bar.F

stream Zipped(A,B,C,D,E,F)
   from Foo, Bar
   emit consuming[Foo,Bar]
       (A,B,C,D,E,F): Foo.A, Foo.B, Foo.C, Bar.D, Bar.E, Bar.F


stream Tagged(T,A,B,C)
   from Foo, Bar
   emit consuming[Foo]
       (T,A,B,C): ("Foo", Foo.A, Foo.B, Foo.C)

   emit consuming[Bar]
       (T,A,B,C): ("Bar", Bar.A, Bar.B, Bar.C)


//Emits two tuples.  One is an echo, the other is reverses A & B
stream foo(A,B)
stream flipped(A,B)
   from foo
   emit consuming[Foo]
     (A,B): (B,A)
     
   emit consuming[Foo]
     (A,B): (A,B)
     
     
stream incremented(A)
   from foo
   emit consuming[Foo]
      (A) : Add1(A)